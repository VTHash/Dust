<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>DustClaim - Linea</title>

    <style>
      :root{
        --bg:#05080d;
        --text:#e6edf3;
        --muted:rgba(230,237,243,0.75);
        --blue:#38bdf8;
        --green:#22c55e;
      }

      * { box-sizing: border-box; }

      body{
        margin:0;
        font-family: ui-sans-serif, system-ui, Arial;
        background: var(--bg);
        color: var(--text);
      }

      .wrap{
        width:100%;
        max-width:none;
        margin:0;
        padding: 14px 12px 18px;
      }

      @media (min-width: 520px){
        .wrap{ padding: 28px 18px; max-width: 560px; margin: 0 auto; }
      }

      .card{
        position: relative;
        width:100%;
        background: rgba(255,255,255,0.025);
        border-radius: 20px;
        padding: 18px;

        border: 2px solid var(--blue);
        box-shadow:
          0 0 10px rgba(56,189,248,1),
          0 0 28px rgba(56,189,248,0.95),
          0 0 55px rgba(56,189,248,0.85),
          0 0 105px rgba(56,189,248,0.7);
      }

      .card::before{
        content:"";
        position:absolute;
        inset: 8px;
        border-radius: 14px;
        border: 1.5px solid var(--green);
        pointer-events:none;
        box-shadow:
          inset 0 0 12px rgba(34,197,94,0.85),
          0 0 12px rgba(34,197,94,0.9),
          0 0 26px rgba(34,197,94,0.75);
      }

      .title{
        font-size: 22px;
        font-weight: 900;
        letter-spacing: 0.4px;
        margin: 0 0 8px;
        text-shadow:
          0 0 14px rgba(56,189,248,0.9),
          0 0 10px rgba(34,197,94,0.6);
      }

      .muted{ color: var(--muted); font-size: 13px; }

      .note{
        margin-top: 8px;
        font-size: 12px;
        color: rgba(230,237,243,0.72);
        line-height: 1.35;
      }

      .note b{
        color: #baffd8;
        text-shadow: 0 0 8px rgba(34,197,94,0.65);
      }

      .tip{
        margin-top: 10px;
        padding: 10px 12px;
        border-radius: 14px;
        background: rgba(56,189,248,0.08);
        border: 1px solid rgba(56,189,248,0.18);
        box-shadow: inset 0 0 10px rgba(56,189,248,0.22);
        color: rgba(230,237,243,0.85);
      }

      .row{
        display:flex;
        justify-content:space-between;
        gap: 12px;
        padding: 10px 0;
        border-bottom: 1px solid rgba(34,197,94,0.25);
      }

      .row:last-child{ border-bottom:0; }

      .value{
        text-align:right;
        max-width: 62%;
        overflow:hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
      }

      .btn{
        width:100%;
        padding: 15px;
        border-radius: 16px;
        border:none;
        font-weight: 900;
        cursor:pointer;
        letter-spacing: 0.3px;
        touch-action: manipulation;
      }

      .btn-secondary{
        background: rgba(34,197,94,0.12);
        color: #baffd8;
        box-shadow:
          inset 0 0 10px rgba(34,197,94,0.45),
          0 0 16px rgba(34,197,94,0.55);
      }

      .btn-primary{
        background: linear-gradient(135deg, var(--green), var(--blue));
        color: #02130b;
        box-shadow:
          0 0 12px rgba(34,197,94,1),
          0 0 28px rgba(56,189,248,0.95),
          0 0 60px rgba(56,189,248,0.85);
      }

      .btn-primary:disabled{
        opacity: 0.45;
        box-shadow: none;
        cursor: not-allowed;
      }

      .spacer{ height: 14px; }

      .pill{
        display:inline-block;
        padding: 6px 12px;
        border-radius: 999px;
        font-size: 12px;
        font-weight: 800;
        color: #baffd8;
        background: rgba(34,197,94,0.2);
        border: 1px solid var(--green);
        box-shadow:
          inset 0 0 8px rgba(34,197,94,0.9),
          0 0 10px rgba(34,197,94,0.85);
        white-space: nowrap;
      }

      .err{
        color:#ff6b6b;
        font-size: 13px;
        margin-top: 12px;
        white-space: pre-wrap;
      }

      .ok{
        color:#aaffd6;
        font-size: 13px;
        margin-top: 12px;
        white-space: pre-wrap;
        text-shadow:
          0 0 10px rgba(34,197,94,0.8),
          0 0 12px rgba(56,189,248,0.6);
      }

      code{ color:#bdeeff; }
    </style>
  </head>

  <body>
    <div class="wrap">
      <div class="card">
        <div class="title">Claim your daily DUST</div>
        <div class="muted">Linea mainnet · 5 DUST per day · 6 months per wallet</div>

        <div class="note">
          Minimum requirement: wallet must hold at least <b id="minEthLabel">0.001 ETH</b> to claim.
          <span class="muted">(Your balance: <span id="ethBal">—</span>)</span>
          <div class="tip"><b>Tip:</b> Open app in MetaMask for smooth transfer.</div>
        </div>

        <div class="spacer"></div>

        <button id="connectBtn" class="btn btn-secondary">Connect MetaMask</button>

        <div class="spacer"></div>

        <div class="row">
          <div class="muted">Wallet</div>
          <div id="wallet" class="muted value">Not connected</div>
        </div>

        <div class="row">
          <div class="muted">Network</div>
          <div id="network" class="muted value">—</div>
        </div>

        <div class="row">
          <div class="muted">Can claim now</div>
          <div id="canClaim" class="pill">—</div>
        </div>

        <div class="row">
          <div class="muted">Next claim</div>
          <div id="nextClaim" class="muted value">—</div>
        </div>

        <div class="row">
          <div class="muted">Window ends</div>
          <div id="windowEnds" class="muted value">—</div>
        </div>

        <div class="row">
          <div class="muted">Remaining supply</div>
          <div id="remaining" class="muted value">—</div>
        </div>

        <div class="spacer"></div>

        <button id="claimBtn" class="btn btn-primary" disabled>Claim 5 DUST</button>

        <div id="msg" class="ok" style="display:none;"></div>
        <div id="err" class="err" style="display:none;"></div>
      </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/ethers@6.15.0/dist/ethers.umd.min.js"></script>

    <script>
      // ====== CONFIG ======
      const LINEA_CHAIN_ID_DEC = 59144;
      const LINEA_CHAIN_ID_HEX = "0xE708";

      const DUST_CONTRACT_ADDRESS = "0xF312Ec9f8087C87fbF3439B0369eA233a1EE4A7D";

      const MIN_ETH_REQUIRED = "0.001";

      const DUST_ABI = [
        "function claimDaily() external",
        "function canClaim(address user) view returns (bool ok, string reason)",
        "function nextClaimTime(address user) view returns (uint256)",
        "function windowEndTime(address user) view returns (uint256)",
        "function firstClaimAt(address user) view returns (uint256)",
        "function cap() view returns (uint256)",
        "function totalSupply() view returns (uint256)",
        "function decimals() view returns (uint8)"
      ];

      // ====== UI helpers ======
      const $ = (id) => document.getElementById(id);

      function setMsg(text) {
        $("msg").style.display = "block";
        $("err").style.display = "none";
        $("msg").textContent = text;
      }

      function setErr(text) {
        $("err").style.display = "block";
        $("msg").style.display = "none";
        $("err").textContent = text;
      }

      function clearAlerts() {
        $("msg").style.display = "none";
        $("err").style.display = "none";
        $("msg").textContent = "";
        $("err").textContent = "";
      }

      function fmtTime(ts) {
        if (!ts || ts === 0) return "—";
        const d = new Date(Number(ts) * 1000);
        return d.toLocaleString();
      }

      function shortAddr(a) {
        return a ? a.slice(0, 6) + "…" + a.slice(-4) : "—";
      }

      function fmtUnits(amount, decimals = 18) {
        try { return ethers.formatUnits(amount, decimals); }
        catch { return String(amount); }
      }

      function fmtEth(wei) {
        try {
          const eth = ethers.formatEther(wei);
          const num = Number(eth);
          if (!Number.isFinite(num)) return eth;
          return num.toLocaleString(undefined, { maximumFractionDigits: 6 });
        } catch {
          return "—";
        }
      }

      function pad2(n) { return String(n).padStart(2, "0"); }

      function formatCountdown(secondsLeft) {
        if (secondsLeft <= 0) return "Ready now";
        const h = Math.floor(secondsLeft / 3600);
        const m = Math.floor((secondsLeft % 3600) / 60);
        const s = Math.floor(secondsLeft % 60);
        return `Claim in: ${pad2(h)}:${pad2(m)}:${pad2(s)}`;
      }

      // ====== state ======
      let provider = null;
      let signer = null;
      let user = null;
      let contract = null;
      let decimals = 18;

      let countdownInterval = null;
      let ethPollInterval = null;

      let latestNextClaimAt = 0;
      let latestCanClaimNow = false;

      function stopIntervals() {
        if (countdownInterval) { clearInterval(countdownInterval); countdownInterval = null; }
        if (ethPollInterval) { clearInterval(ethPollInterval); ethPollInterval = null; }
      }

      // IMPORTANT: Only call this AFTER eth_requestAccounts succeeded.
      async function ensureLineaConnected() {
        const chainIdHex = await window.ethereum.request({ method: "eth_chainId" });
        const chainId = parseInt(chainIdHex, 16);

        if (chainId === LINEA_CHAIN_ID_DEC) return;

        try {
          await window.ethereum.request({
            method: "wallet_switchEthereumChain",
            params: [{ chainId: LINEA_CHAIN_ID_HEX }]
          });
        } catch (e) {
          const msg = String(e?.message || "");
          if (e && (e.code === 4902 || msg.includes("Unrecognized chain"))) {
            await window.ethereum.request({
              method: "wallet_addEthereumChain",
              params: [{
                chainId: LINEA_CHAIN_ID_HEX,
                chainName: "Linea",
                nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
                rpcUrls: ["https://rpc.linea.build"],
                blockExplorerUrls: ["https://lineascan.build"]
              }]
            });

            // Try switch again after adding
            await window.ethereum.request({
              method: "wallet_switchEthereumChain",
              params: [{ chainId: LINEA_CHAIN_ID_HEX }]
            });
          } else {
            throw e;
          }
        }
      }

      async function updateNetworkLabel() {
        try {
          if (!provider) { $("network").textContent = "—"; return; }
          const net = await provider.getNetwork();
          const isLinea = Number(net.chainId) === LINEA_CHAIN_ID_DEC;
          $("network").textContent = `${net.chainId}${isLinea ? " (Linea)" : ""}`;
        } catch {
          $("network").textContent = "—";
        }
      }

      async function updateEthBalance() {
        if (!provider || !user) return;
        try {
          const bal = await provider.getBalance(user);
          $("ethBal").textContent = `${fmtEth(bal)} ETH`;
        } catch {
          $("ethBal").textContent = "—";
        }
      }

      function startEthPoll() {
        if (ethPollInterval) clearInterval(ethPollInterval);
        ethPollInterval = setInterval(async () => {
          if (!user || !provider) return;
          await updateEthBalance();
        }, 12000);
      }

      function startCountdown() {
        if (countdownInterval) clearInterval(countdownInterval);
        countdownInterval = setInterval(async () => {
          if (!user || !contract) return;

          const nowSec = Math.floor(Date.now() / 1000);
          const secondsLeft = Number(latestNextClaimAt) - nowSec;

          if (latestCanClaimNow) {
            $("nextClaim").textContent = "Ready now";
            $("claimBtn").disabled = false;
            return;
          }

          $("nextClaim").textContent = formatCountdown(secondsLeft);

          if (secondsLeft <= 0) {
            try { await refresh(); } catch {}
          }
        }, 1000);
      }

      async function connect() {
        clearAlerts();
        stopIntervals();

        $("minEthLabel").textContent = `${MIN_ETH_REQUIRED} ETH`;
        $("ethBal").textContent = "—";

        if (!window.ethereum || !window.ethereum.isMetaMask) {
          setErr("MetaMask not detected. Open in MetaMask browser or install MetaMask extension.");
          return;
        }

        if (!DUST_CONTRACT_ADDRESS || DUST_CONTRACT_ADDRESS.includes("0xYOUR_")) {
          setErr("Set DUST_CONTRACT_ADDRESS in the script before using this page.");
          return;
        }

        try {
          // 1) AUTHORIZATION FIRST (prevents 4100)
          const accounts = await window.ethereum.request({ method: "eth_requestAccounts" });
          user = accounts?.[0] || null;

          if (!user) {
            setErr("No account selected in MetaMask.");
            return;
          }

          $("wallet").textContent = shortAddr(user);

          // 2) Then create provider/signer
          provider = new ethers.BrowserProvider(window.ethereum);
          signer = await provider.getSigner();

          // 3) Only AFTER authorization: switch/add Linea
          await ensureLineaConnected();

          // 4) Update labels after chain switch
          await updateNetworkLabel();

          // 5) Build contract + load decimals
          contract = new ethers.Contract(DUST_CONTRACT_ADDRESS, DUST_ABI, signer);
          try { decimals = await contract.decimals(); } catch { decimals = 18; }

          await refresh();
          startCountdown();

          await updateEthBalance();
          startEthPoll();

          setMsg("Connected. Ready.");
        } catch (e) {
          const msg = e?.shortMessage || e?.reason || e?.message || String(e);

          // User rejected connect
          if (e && (e.code === 4001 || String(msg).toLowerCase().includes("user rejected"))) {
            setErr("Connection request was rejected.");
            return;
          }

          setErr(msg);
        }
      }

      async function refresh() {
        if (!user || !contract || !provider) return;

        await updateNetworkLabel();
        await updateEthBalance();

        // If user is on the wrong chain, disable claim and show message.
        try {
          const net = await provider.getNetwork();
          const isLinea = Number(net.chainId) === LINEA_CHAIN_ID_DEC;
          if (!isLinea) {
            $("canClaim").textContent = "NO (Wrong network)";
            $("nextClaim").textContent = "Switch to Linea";
            $("windowEnds").textContent = "—";
            $("remaining").textContent = "—";
            $("claimBtn").disabled = true;
            return;
          }
        } catch {}

        const [okReason, nextClaimAt, windowEndsAt, firstAt, cap, total] = await Promise.all([
          contract.canClaim(user),
          contract.nextClaimTime(user),
          contract.windowEndTime(user),
          contract.firstClaimAt(user),
          contract.cap(),
          contract.totalSupply()
        ]);

        const canClaimNow = okReason[0];
        const reason = okReason[1];

        latestCanClaimNow = canClaimNow;
        latestNextClaimAt = Number(nextClaimAt);

        const started = (firstAt && Number(firstAt) !== 0);
        const remainingSupply = cap - total;

        $("canClaim").textContent = canClaimNow ? "YES" : `NO (${reason})`;

        if (!started) {
          $("nextClaim").textContent = "Now (first claim)";
        } else if (canClaimNow) {
          $("nextClaim").textContent = "Ready now";
        } else {
          const nowSec = Math.floor(Date.now() / 1000);
          $("nextClaim").textContent = formatCountdown(Number(nextClaimAt) - nowSec);
        }

        $("windowEnds").textContent = started ? fmtTime(windowEndsAt) : "After first claim";
        $("remaining").textContent = `${Number(fmtUnits(remainingSupply, decimals)).toLocaleString()} DUST`;

        $("claimBtn").disabled = !canClaimNow;
        startCountdown();
      }

      async function claim() {
        clearAlerts();
        try {
          if (!user || !contract) throw new Error("Not connected.");

          // If user switched away from Linea, force them to switch back (authorized already)
          await ensureLineaConnected();
          await updateNetworkLabel();

          $("claimBtn").disabled = true;
          setMsg("Confirm the transaction in MetaMask...");

          const tx = await contract.claimDaily();
          setMsg(`Transaction sent: ${tx.hash}\nWaiting for confirmation...`);

          const receipt = await tx.wait();
          setMsg(`Confirmed in block ${receipt.blockNumber}.\nYou received 5 DUST.`);

          await refresh();
        } catch (e) {
          const msg = e?.shortMessage || e?.reason || e?.message || String(e);
          setErr(msg);
          try { await refresh(); } catch {}
        }
      }

      // Wallet events
      if (window.ethereum) {
        window.ethereum.on("accountsChanged", async (accounts) => {
          // Do not auto-run eth_requestAccounts here; just update state and refresh.
          user = accounts?.[0] || null;
          $("wallet").textContent = user ? shortAddr(user) : "Not connected";
          if (!user) {
            stopIntervals();
            $("claimBtn").disabled = true;
            return;
          }
          try { await refresh(); } catch {}
        });

        window.ethereum.on("chainChanged", async () => {
          try { await refresh(); } catch {}
        });
      }

      $("connectBtn").addEventListener("click", connect);
      $("claimBtn").addEventListener("click", claim);
      $("minEthLabel").textContent = `${MIN_ETH_REQUIRED} ETH`;
    </script>
  </body>
</html>