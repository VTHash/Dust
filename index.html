<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>DustClaim - Linea</title>

    <style>
      :root{
        --bg0:#05080d;
        --bg1:#070d14;
        --text:#e6edf3;
        --muted:rgba(230,237,243,.72);
        --muted2:rgba(230,237,243,.58);

        --blue:#38bdf8;
        --green:#22c55e;

        --card:rgba(255,255,255,.03);
        --line:rgba(34,197,94,.22);

        --shadowBlue: 0 0 8px rgba(56,189,248,1),
                      0 0 24px rgba(56,189,248,.85),
                      0 0 54px rgba(56,189,248,.65);

        --shadowGreen: inset 0 0 10px rgba(34,197,94,.55),
                       0 0 16px rgba(34,197,94,.45);
      }

      *{ box-sizing:border-box; }

      body{
        margin:0;
        font-family: ui-sans-serif, system-ui, Arial;
        color: var(--text);
        background: var(--bg0);
      }

      .wrap{
        width:100%;
        max-width: 860px;
        margin: 0 auto;
        padding: 18px 14px 34px;
        padding-bottom: calc(34px + env(safe-area-inset-bottom));
        min-height: calc(100vh - 120px);

        background:
          radial-gradient(1200px 900px at 50% 10%, rgba(99,102,241,.38), transparent 60%),
          radial-gradient(1000px 800px at 50% 90%, rgba(168,85,247,.30), transparent 65%),
          linear-gradient(180deg, rgba(124,58,237,.45), rgba(139,92,246,.38), rgba(99,102,241,.28));

        border-radius: 28px;
        box-shadow:
          0 0 0 1px rgba(255,255,255,.06),
          0 0 60px rgba(139,92,246,.25),
          inset 0 0 120px rgba(168,85,247,.18);
      }

      .card{
        position:relative;
        margin-top: 16px;
        padding: 16px;
        border-radius: 24px;

        background: rgba(10,14,30,.55);
        border: 2px solid rgba(99,102,241,.65);

        box-shadow:
          0 0 28px rgba(99,102,241,.55),
          inset 0 0 40px rgba(168,85,247,.35);

        overflow:hidden;
      }

      .card::before{
        content:"";
        position:absolute;
        inset: 8px;
        border-radius: 18px;

        border: 1.5px solid rgba(168,85,247,.75);

        box-shadow:
          inset 0 0 30px rgba(168,85,247,.45),
          0 0 24px rgba(139,92,246,.55);

        pointer-events:none;
      }

      .title{
        margin:0 0 6px;
        font-size: 18px;
        font-weight: 950;
        letter-spacing: .35px;
        color: var(--text);
        text-shadow:
          0 0 14px rgba(56,189,248,.55),
          0 0 12px rgba(34,197,94,.35);
      }

      .muted{
        color: var(--muted);
        font-size: 12.5px;
        opacity: .78;
      }

      .note{
        margin-top: 12px;
        font-size: 12.5px;
        line-height: 1.45;
        color: var(--muted);
      }

      .note b{
        color: rgba(230,237,243,.95);
        text-shadow: 0 0 10px rgba(34,197,94,.22);
      }

      .tip{
        margin-top: 10px;
        padding: 12px;
        border-radius: 16px;
        background: rgba(18,22,46,.65);
        border: 1px solid rgba(99,102,241,.45);
        box-shadow: 0 0 18px rgba(99,102,241,.25);
        color: rgba(230,237,243,.88);
      }

      .row{
        position:relative;
        display:flex;
        justify-content:space-between;
        gap: 12px;
        padding: 14px;
        border-radius: 18px;

        background: rgba(18,22,46,.65);
        border: 1px solid rgba(168,85,247,.35);

        box-shadow:
          inset 0 0 22px rgba(168,85,247,.28),
          0 0 18px rgba(99,102,241,.22);

        margin-top: 12px;
      }

      .value{
        text-align:right;
        max-width: 62%;
        overflow:hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
        color: rgba(230,237,243,.95);
        font-weight: 900;
      }

      .btn{
        width:100%;
        padding: 15px;
        border-radius: 16px;
        border:none;
        font-weight: 950;
        cursor:pointer;
        letter-spacing: .3px;
        touch-action: manipulation;
      }

      .btn-secondary{
        background: rgba(18,22,46,.65);
        border: 1px solid rgba(99,102,241,.45);
        color: rgba(230,237,243,.92);
        box-shadow: 0 0 18px rgba(99,102,241,.25);
      }

      .btn-secondary:hover{ filter: brightness(1.05); }

      .btn-primary{
        background: linear-gradient(135deg, rgba(124,58,237,.9), rgba(56,189,248,.95));
        color: #061020;
        box-shadow:
          0 0 18px rgba(99,102,241,.40),
          0 0 26px rgba(56,189,248,.35),
          inset 0 0 18px rgba(168,85,247,.25);
      }

      .btn-primary:hover{ filter: brightness(1.05); }

      .btn-primary:disabled{
        opacity: .45;
        box-shadow: none;
        cursor: not-allowed;
      }

      .btn-row{
        display:grid;
        grid-template-columns: 1fr;
        gap: 10px;
      }

      @media (min-width: 520px){
        .btn-row{ grid-template-columns: 1fr 1fr; }
      }

      .spacer{ height: 14px; }

      .pill{
        display:inline-block;
        padding: 6px 12px;
        border-radius: 999px;
        font-size: 12px;
        font-weight: 950;
        color: rgba(230,237,243,.92);
        background: rgba(255,255,255,.04);
        border: 1px solid rgba(99,102,241,.45);
        box-shadow: 0 0 18px rgba(99,102,241,.18);
        white-space: nowrap;
      }

      .err, .ok{
        margin-top: 14px;
        padding: 12px;
        border-radius: 16px;
        background: rgba(18,22,46,.65);
        white-space: pre-wrap;
      }

      .ok{
        border: 1px solid rgba(99,102,241,.45);
        box-shadow: 0 0 18px rgba(99,102,241,.25);
        color: rgba(230,237,243,.88);
      }

      .err{
        border: 1px solid rgba(255,107,107,.65);
        box-shadow: 0 0 18px rgba(255,107,107,.25);
        color: rgba(255,220,220,.92);
      }

      code{
        font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace;
        font-size: 12px;
        color: rgba(230,237,243,.92);
        background: rgba(255,255,255,.04);
        border: 1px solid rgba(99,102,241,.45);
        border-radius: 10px;
        padding: 2px 8px;
      }

      @media (min-width: 740px){
        .wrap{ padding: 22px 16px 44px; }
        .title{ font-size: 22px; }
        .card{ padding: 20px; }
      }

      @media (max-width: 420px){
        .title{ font-size: 17px; }
        .value{ font-size: 13.5px; }
        .card{ border-radius: 20px; }
      }
    </style>
  </head>

  <body>
    <div class="wrap">
      <div class="card">
        <div class="title">Claim your daily DUST</div>
        <div class="muted">Linea mainnet · 5 DUST per day · 6 months per wallet</div>

        <div class="note">
          Minimum requirement: wallet must hold at least <b id="minEthLabel">0.001 ETH</b> to claim.
          <span class="muted">(Your balance: <span id="ethBal">—</span>)</span>
          <div class="tip"><b>Tip:</b> Any browser works via WalletConnect. MetaMask browser/extension works too.</div>
        </div>

        <div class="spacer"></div>

        <div class="btn-row">
          <button id="connectBtn" class="btn btn-secondary">Connect wallet</button>
          <button id="switchLineaBtn" class="btn btn-secondary" disabled>Switch to Linea</button>
        </div>

        <div class="spacer"></div>

        <div class="row">
          <div class="muted">Wallet</div>
          <div id="wallet" class="muted value">Not connected</div>
        </div>

        <div class="row">
          <div class="muted">Network</div>
          <div id="network" class="muted value">—</div>
        </div>

        <div class="row">
          <div class="muted">Can claim now</div>
          <div id="canClaim" class="pill">—</div>
        </div>

        <div class="row">
          <div class="muted">Next claim</div>
          <div id="nextClaim" class="muted value">—</div>
        </div>

        <div class="row">
          <div class="muted">Window ends</div>
          <div id="windowEnds" class="muted value">—</div>
        </div>

        <div class="row">
          <div class="muted">Remaining supply</div>
          <div id="remaining" class="muted value">—</div>
        </div>

        <div class="spacer"></div>

        <button id="claimBtn" class="btn btn-primary" disabled>Claim 5 DUST</button>

        <div id="msg" class="ok" style="display:none;"></div>
        <div id="err" class="err" style="display:none;"></div>
      </div>
    </div>

    <script type="module">
      // ========= IMPORTANT =========
      // WalletConnect/Reown needs a PROJECT ID here (public).
      // Paste your project id below.
      const WALLETCONNECT_PROJECT_ID = "5cf928ad183dd374ecc95d45aab1e525";
      // =============================

      import { ethers } from "https://esm.sh/ethers@6.15.0";
      import { createAppKit } from "https://esm.sh/@reown/appkit@latest";
      import { EthersAdapter } from "https://esm.sh/@reown/appkit-adapter-ethers@latest";
      import { defineChain } from "https://esm.sh/@reown/appkit/networks@latest";

      // ====== CONFIG ======
      const LINEA_CHAIN_ID_DEC = 59144;
      const LINEA_CHAIN_ID_HEX = "0xE708";
      const DUST_CONTRACT_ADDRESS = "0xF312Ec9f8087C87fbF3439B0369eA233a1EE4A7D";
      const MIN_ETH_REQUIRED = "0.001";

      // Linea chain definition (safe even if not shipped in networks list)
      const linea = defineChain({
        id: LINEA_CHAIN_ID_DEC,
        name: "Linea",
        nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
        rpcUrls: { default: { http: ["https://rpc.linea.build"] } },
        blockExplorers: { default: { name: "LineaScan", url: "https://lineascan.build" } }
      });

      const DUST_ABI = [
        "function claimDaily() external",
        "function canClaim(address user) view returns (bool ok, string reason)",
        "function nextClaimTime(address user) view returns (uint256)",
        "function windowEndTime(address user) view returns (uint256)",
        "function firstClaimAt(address user) view returns (uint256)",
        "function cap() view returns (uint256)",
        "function totalSupply() view returns (uint256)",
        "function decimals() view returns (uint8)"
      ];

      // ====== UI helpers ======
      const $ = (id) => document.getElementById(id);

      function setMsg(text) {
        $("msg").style.display = "block";
        $("err").style.display = "none";
        $("msg").textContent = text;
      }

      function setErr(text) {
        $("err").style.display = "block";
        $("msg").style.display = "none";
        $("err").textContent = text;
      }

      function clearAlerts() {
        $("msg").style.display = "none";
        $("err").style.display = "none";
        $("msg").textContent = "";
        $("err").textContent = "";
      }

      function fmtTime(ts) {
        if (!ts || ts === 0) return "—";
        const d = new Date(Number(ts) * 1000);
        return d.toLocaleString();
      }

      function shortAddr(a) {
        return a ? a.slice(0, 6) + "…" + a.slice(-4) : "—";
      }

      function fmtUnits(amount, decimals = 18) {
        try { return ethers.formatUnits(amount, decimals); }
        catch { return String(amount); }
      }

      function fmtEth(wei) {
        try {
          const eth = ethers.formatEther(wei);
          const num = Number(eth);
          if (!Number.isFinite(num)) return eth;
          return num.toLocaleString(undefined, { maximumFractionDigits: 6 });
        } catch {
          return "—";
        }
      }

      function pad2(n) { return String(n).padStart(2, "0"); }

      function formatCountdown(secondsLeft) {
        if (secondsLeft <= 0) return "Ready now";
        const h = Math.floor(secondsLeft / 3600);
        const m = Math.floor((secondsLeft % 3600) / 60);
        const s = Math.floor(secondsLeft % 60);
        return `Claim in: ${pad2(h)}:${pad2(m)}:${pad2(s)}`;
      }

      // ====== AppKit init ======
      $("minEthLabel").textContent = `${MIN_ETH_REQUIRED} ETH`;

      if (!WALLETCONNECT_PROJECT_ID || WALLETCONNECT_PROJECT_ID.includes("PASTE_")) {
        setErr("Set WALLETCONNECT_PROJECT_ID in the code, then re-upload to IPFS.");
      }

      const appKit = createAppKit({
        adapters: [new EthersAdapter()],
        networks: [linea],
        projectId: WALLETCONNECT_PROJECT_ID,
        metadata: {
          name: "DustClaim",
          description: "Claim your daily DUST on Linea",
          url: "https://dustclaim.eth.limo",
          icons: ["https://dustclaim.xyz/favicon.ico"]
        },
        features: {
          analytics: false
        }
      });

      // ====== State ======
      let walletProvider = null; // EIP-1193 provider from AppKit
      let provider = null; // ethers BrowserProvider
      let signer = null;
      let user = null;
      let contract = null;
      let decimals = 18;

      let countdownInterval = null;
      let ethPollInterval = null;

      let latestNextClaimAt = 0;
      let latestCanClaimNow = false;

      function stopIntervals() {
        if (countdownInterval) { clearInterval(countdownInterval); countdownInterval = null; }
        if (ethPollInterval) { clearInterval(ethPollInterval); ethPollInterval = null; }
      }

      async function ensureLineaConnected(eip1193) {
        const chainIdHex = await eip1193.request({ method: "eth_chainId" });
        const chainId = parseInt(chainIdHex, 16);
        if (chainId === LINEA_CHAIN_ID_DEC) return;

        try {
          await eip1193.request({
            method: "wallet_switchEthereumChain",
            params: [{ chainId: LINEA_CHAIN_ID_HEX }]
          });
        } catch (e) {
          const msg = String(e?.message || "");
          if (e && (e.code === 4902 || msg.includes("Unrecognized chain"))) {
            await eip1193.request({
              method: "wallet_addEthereumChain",
              params: [{
                chainId: LINEA_CHAIN_ID_HEX,
                chainName: "Linea",
                nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
                rpcUrls: ["https://rpc.linea.build"],
                blockExplorerUrls: ["https://lineascan.build"]
              }]
            });

            await eip1193.request({
              method: "wallet_switchEthereumChain",
              params: [{ chainId: LINEA_CHAIN_ID_HEX }]
            });
          } else {
            throw e;
          }
        }
      }

      async function updateNetworkLabel() {
        try {
          if (!provider) { $("network").textContent = "—"; return; }
          const net = await provider.getNetwork();
          const isLinea = Number(net.chainId) === LINEA_CHAIN_ID_DEC;
          $("network").textContent = `${net.chainId}${isLinea ? " (Linea)" : ""}`;
          $("switchLineaBtn").disabled = isLinea ? true : false;
        } catch {
          $("network").textContent = "—";
          $("switchLineaBtn").disabled = true;
        }
      }

      async function updateEthBalance() {
        if (!provider || !user) return;
        try {
          const bal = await provider.getBalance(user);
          $("ethBal").textContent = `${fmtEth(bal)} ETH`;
        } catch {
          $("ethBal").textContent = "—";
        }
      }

      function startEthPoll() {
        if (ethPollInterval) clearInterval(ethPollInterval);
        ethPollInterval = setInterval(updateEthBalance, 12000);
      }

      function startCountdown() {
        if (countdownInterval) clearInterval(countdownInterval);
        countdownInterval = setInterval(async () => {
          if (!user || !contract) return;

          const nowSec = Math.floor(Date.now() / 1000);
          const secondsLeft = Number(latestNextClaimAt) - nowSec;

          if (latestCanClaimNow) {
            $("nextClaim").textContent = "Ready now";
            $("claimBtn").disabled = false;
            return;
          }

          $("nextClaim").textContent = formatCountdown(secondsLeft);

          if (secondsLeft <= 0) {
            try { await refresh(); } catch {}
          }
        }, 1000);
      }

      async function buildContract() {
        contract = new ethers.Contract(DUST_CONTRACT_ADDRESS, DUST_ABI, signer);
        try { decimals = await contract.decimals(); } catch { decimals = 18; }
      }

      async function connectWithAppKit() {
        clearAlerts();
        stopIntervals();

        if (!WALLETCONNECT_PROJECT_ID || WALLETCONNECT_PROJECT_ID.includes("PASTE_")) {
          setErr("Missing WALLETCONNECT_PROJECT_ID. Add it, re-upload to IPFS, then try again.");
          return;
        }

        // Open AppKit modal
        await appKit.open({ view: "Connect" });

        // After connect, AppKit will emit providers/accounts; we also try to pull immediately:
        try {
          // Provider access is event-driven; this may still be null right after modal closes in some wallets.
          // So we rely on subscribeProviders below as the source of truth.
          setMsg("Connecting...");
        } catch {}
      }

      async function syncFromProvider(p) {
        walletProvider = p;

        if (!walletProvider) {
          user = null;
          provider = null;
          signer = null;
          contract = null;
          $("wallet").textContent = "Not connected";
          $("network").textContent = "—";
          $("ethBal").textContent = "—";
          $("canClaim").textContent = "—";
          $("nextClaim").textContent = "—";
          $("windowEnds").textContent = "—";
          $("remaining").textContent = "—";
          $("claimBtn").disabled = true;
          $("switchLineaBtn").disabled = true;
          stopIntervals();
          return;
        }

        provider = new ethers.BrowserProvider(walletProvider);
        signer = await provider.getSigner();
        user = await signer.getAddress();

        $("wallet").textContent = shortAddr(user);

        // Ensure Linea after connection (some wallets connect on a different chain)
        await ensureLineaConnected(walletProvider);

        await updateNetworkLabel();
        await buildContract();

        await refresh();
        startCountdown();

        await updateEthBalance();
        startEthPoll();

        setMsg("Connected. Ready.");
      }

      // Subscribe to provider changes from AppKit (this is what makes it reliable across wallets/browsers)
      appKit.subscribeProviders(async (state) => {
        // state.walletProvider is the EIP-1193 provider we need
        // (AppKit provides it when connected)
        try {
          if (state?.walletProvider) {
            await syncFromProvider(state.walletProvider);
          } else {
            await syncFromProvider(null);
          }
        } catch (e) {
          setErr(e?.message || String(e));
        }
      });

      // Also reflect account/network changes nicely
      appKit.subscribeAccount((acct) => {
        // acct.isConnected, acct.address
        if (!acct?.isConnected) {
          // provider subscription will clean up; keep UI consistent
          $("wallet").textContent = "Not connected";
          $("claimBtn").disabled = true;
        }
      });

      appKit.subscribeNetwork(() => {
        // provider subscription + refresh handles it, but this keeps UI snappy
        refresh().catch(() => {});
      });

      async function refresh() {
        if (!user || !contract || !provider) return;

        await updateNetworkLabel();
        await updateEthBalance();

        // If wrong chain, show a clear message
        try {
          const net = await provider.getNetwork();
          const isLinea = Number(net.chainId) === LINEA_CHAIN_ID_DEC;
          if (!isLinea) {
            $("canClaim").textContent = "NO (Wrong network)";
            $("nextClaim").textContent = "Switch to Linea";
            $("windowEnds").textContent = "—";
            $("remaining").textContent = "—";
            $("claimBtn").disabled = true;
            $("switchLineaBtn").disabled = false;
            return;
          }
        } catch {}

        const [okReason, nextClaimAt, windowEndsAt, firstAt, cap, total] = await Promise.all([
          contract.canClaim(user),
          contract.nextClaimTime(user),
          contract.windowEndTime(user),
          contract.firstClaimAt(user),
          contract.cap(),
          contract.totalSupply()
        ]);

        const canClaimNow = okReason[0];
        const reason = okReason[1];

        latestCanClaimNow = canClaimNow;
        latestNextClaimAt = Number(nextClaimAt);

        const started = (firstAt && Number(firstAt) !== 0);
        const remainingSupply = cap - total;

        $("canClaim").textContent = canClaimNow ? "YES" : `NO (${reason})`;

        if (!started) {
          $("nextClaim").textContent = "Now (first claim)";
        } else if (canClaimNow) {
          $("nextClaim").textContent = "Ready now";
        } else {
          const nowSec = Math.floor(Date.now() / 1000);
          $("nextClaim").textContent = formatCountdown(Number(nextClaimAt) - nowSec);
        }

        $("windowEnds").textContent = started ? fmtTime(windowEndsAt) : "After first claim";
        $("remaining").textContent = `${Number(fmtUnits(remainingSupply, decimals)).toLocaleString()} DUST`;

        $("claimBtn").disabled = !canClaimNow;
        $("switchLineaBtn").disabled = false;

        startCountdown();
      }

      async function switchToLinea() {
        clearAlerts();
        try {
          if (!walletProvider) throw new Error("Connect a wallet first.");
          await ensureLineaConnected(walletProvider);
          await refresh();
          setMsg("Switched to Linea.");
        } catch (e) {
          setErr(e?.message || String(e));
        }
      }

      async function claim() {
        clearAlerts();
        try {
          if (!user || !contract || !walletProvider) throw new Error("Not connected.");

          await ensureLineaConnected(walletProvider);
          await updateNetworkLabel();

          $("claimBtn").disabled = true;
          setMsg("Confirm the transaction in your wallet...");

          const tx = await contract.claimDaily();
          setMsg(`Transaction sent: ${tx.hash}\nWaiting for confirmation...`);

          const receipt = await tx.wait();
          setMsg(`Confirmed in block ${receipt.blockNumber}.\nYou received 5 DUST.`);

          await refresh();
        } catch (e) {
          const msg = e?.shortMessage || e?.reason || e?.message || String(e);
          setErr(msg);
          try { await refresh(); } catch {}
        }
      }

      $("connectBtn").addEventListener("click", connectWithAppKit);
      $("switchLineaBtn").addEventListener("click", switchToLinea);
      $("claimBtn").addEventListener("click", claim);

      // Optional: if user lands already connected (some wallets persist session)
      // the subscribeProviders handler will pick it up automatically.
    </script>
  </body>
</html>